\section{Grundlagen der Verbindungstechnologien}
	Da die Nutzbarkeit der Übertragungstechnologien für die Verbindungskonfiguration bereits in \cite{aiProject} überprüft wurden, soll noch einmal jede Technologie in ihrer Funktionsweise kurz vorgestellt werden und der Ablauf eines Verbindungsaufbaus beschrieben werden. Im Gegensatz zu Wi-Fi Direct werden die Zustände beim Verbindungsaufbau intern gehandhabt. Es ist dennoch hilfreich zu verstehen, wie eine Technologie funktioniert, um Fehlerursachen bei einem Verbindungsaufbau leicht identifizieren zu können. Die genutzten Bibliothek dieser Technologien werden in Abschnitt \ref{section:implementation} beschrieben. Zwischen der theoretischen Funktionsweise und ihrer Umsetzung besteht immer eine gewisse Abweichung. Diese Abweichungen sollten jedoch bei der Anbindung der Bibliotheken nicht mehr extern bemerkbar sein. Eine solche Abweichung ist nicht kritisch für die Nutzung der Technologie, jedoch reduziert sie die Interoperabilität zwischen verschiedenen Anbindungen der Technologie.
	
	\subsection{Bluetooth}
	Um Peripheriegeräte untereinander zu verbinden, kann Bluetooth als drahtloses Übertragungsmedium auf Basis von Piconetzwerken genutzt werden.
	Bluetooth besteht aus mehreren Protokollschichten, die für einen Verbindungsaufbau durchlaufen werden. Zunächst wird ein {\it Asynchronous Conneciton-Less} (ACL) Kanal zum gewünschten Gerät geöffnet, über den alle folgenden Kommunikationen statt-finden werden. Dieser Kanal übernimmt die Aufgabe, die Kommunikation mit dem Bluetooth Chip zu steuern und erhaltene Nachrichten an die nächste Schicht zurückzugeben \cite[S.400]{Sauter}. Das {\it Host Controller interface} (HCI) ist nicht Teil des Bluetooth Standards, wird jedoch in den meisten Implementierungen des Bluetoothstacks genutzt, um niedrigere Schichten der Implementierung von höheren Schichten zu trennen. Wie der Name bereits suggeriert, bildet diese Schnittstelle den Übergang zwischen Bluetooth Modul und Treiber \cite[S.65]{miller}. Auf Basis dieser Schnittstelle erhalten die höheren Protokollschichten nur für das Gerät relevante Datenpakete aus dem ACL Kanal.
	
	Das Logical Link Control and Adaption Protocol (L2CAP) wird als erstes Element der höheren Protokollschichten genutzt, um mehrere gleichzeitige Verbindungen unterschiedlicher Anwendungen über einen einzigen Kanal übertragen zu können \cite[S.395]{Sauter}. Das Service Discovery Protocol (SDP) schließt an dieser Stelle an, um entfernten Geräten die bestehenden Services des Gerätes bekannt machen zu können, sodass dieser eine Auswahl des zu verbindenden Services tätigen kann \cite[S.395]{morrow}. RFCOMM erlaubt es eine serielle Schnittstelle über Bluetooth abzubilden. Da es ebenfalls ein fixer Teil des Bluetooth Protokollstacks ist, kann dies von L2DAP auch ohne SDP genutzt werden. Hierbei ist jedoch zu beachten, dass RFCOMM lediglich 30 Ports unterstützt, was 30 gleichzeitigen Anwendungsverbind-ungen zwischen zwei Bluetooth Geräten entspricht \cite[S.398]{Sauter}. SDP ist nicht in der Lage, diese Anzahl zu erhöhen, da jedoch nicht alle angebotenen Bluetooth Services immer genutzt werden, macht es Sinn, den eigenen Service im SDP zu definieren und so sich von der RFCOMM-Schicht erst einen Port zuweisen zu lassen, wenn die Verbindung tatsächlich genutzt werden soll. Damit eine Anwendung sich so im SDP-Protokoll registrieren kann, muss sie ein entsprechendes Bluetooth Profil, im Falle von RFCOMM das Serial Port Profile, anbieten um die Interoperabilität mit anderen Geräten gewährleisten zu können \cite[S.411]{Sauter}.
	
	\subsection{NFC}
	Near Field Communciation (NFC) ist eine auf RFID basierende Technologie, die sich dahingehend von RFID unterscheidet, dass keine Trennung zwischen lesenden Geräten und passiven Transpondern besteht. Durch diese Aufhebung können NFC Geräte sowohl lesendes Gerät als auch passiver Verbindungsteilnehmer sein und somit eine beidseitige Kompatibilität zu RFID bieten \cite[S.6]{Langer}. NFC ist somit prinzipiell eine Erweiterung des bestehenden Standards, welche in der Lage ist, sich bestehende Infrastruktur zunutze zu machen.
	RFID Lesegeräte erzeugen ein Magnetfeld, um durch Induktion die passiven Chips mit Strom versorgen zu können. Eine Datenübertragung findet dabei immer durch die Antwort der passiven Komponenten auf eine Anfrage der aktiven Komponente der Verbindung. Solange das Trägersignal besteht, können beliebig viele dieser Anfragen gestellt werden \cite[S.89]{Langer}.
	Da NFC-Geräte sowohl aktive als auch passive Komponente dieser Kommunikation repräsentieren können, unterstützt die NFC Architektur drei Funktionsmodi.
	\begin{enumerate}
		\item {\it p2p Modus:} Wenn zwei NFC Geräte miteinander kommunizieren, können diese direkt Daten zueinander übertragen, ohne die anderen beiden Modi nutzen zu müssen. Diese Kommunikationsart teilt sich wiederum in aktiven und passiven Modus auf \cite[S.91]{Langer}. Diese beiden Modi unterscheiden sich dahingehend, dass im aktiven Modus jedes Gerät sein eigenes Trägersignal generieren muss und so ein geringerer Energieverbrauch auf dem initiierendem Gerät besteht \cite[S.94]{Langer}.
		
		\item {\it Lesender Modus:} Um mit passiven RFID Chips kommunizieren zu können, muss das NFC Gerät als Lesegerät agieren \cite[S.99]{Langer}. Hierbei erzeugt das NFC Gerät wieder, ähnlich zum passiven p2p Modus, das Trägersignal für den Kommunikationskanal. Der Datenaustausch findet dann wieder über die Abfrage von Nachrichten statt.
		\item {\it Modus der Karten-Emulation:} Damit ein NFC Gerät auch mit RFID-Lesegeräten kompatibel sein kann, muss es in der Lage sein, eine passive Komponente abzubilden. Dies wird erreicht, indem kein aktives Trägersignal aufgebaut wird und lediglich auf ankommende Anfragen im RFID-Protokoll geantwortet wird \cite[S.100]{Langer}.
	\end{enumerate}
	
	Wenn der p2p Modus nicht direkt unterstützt wird, können auch NFC Geräte durch den lesenden Modus in Verbindung mit einer Emulation einer RFID Chipkarte untereinander kommunizieren. Hierzu muss jedoch im Vorausgang festgelegt werden, welche Seite als aktiver Teilnehmer und welche Seite als passiver Teilnehmer der Kommunikation auftritt \cite[S.101]{Langer}.
	
	\subsection{USB}
	Die Schnittstelle Universal Serial Bus (USB) ist ein kabelgebundenes Bussystem bestehend aus einem Host und vielen Endgeräten mit optionalen Hubs \cite[S.23f]{Kelm}. Ein Hub ist in der Lage über eine USB Schnittstelle mehrere andere USB Geräte anzusteuern und mit Strom zu versorgen. Er erhöht so die physikalische Kapazität für USB Geräte eines Hosts \cite[S.40]{Kelm}. USB erlaubt es, den Großteil der Verbindungslogik im Host zu behandeln, was dazu führt, dass Peripheriegeräte leicht implementiert werden können \cite[S.37]{axelson}. Im Kontext von USB werden diese Geräte als {\it Functions} bezeichnet. Functions können nicht direkt untereinander kommunizieren, dies kann lediglich über Interaktionen mit dem Host vollzogen werden. Da USB-Geräte, welche hinter Hubs angebunden sind, nicht eindeutig vom Host adressiert werden können, spricht ein Host Functions über Broadcastnachrichten auf dem Bus an \cite[S.41]{Kelm}.
	
	Bevor jedoch eine solche Kommunikation stattfinden kann, muss das Gerät auf dem Bus registriert werden. Dazu ist USB in der Lage, Hot Plugging zu erkennen und versucht dann eine Kommunikation mit der neuen Function aufzubauen \cite[S.45]{Kelm}. Wenn die Function auf die Kommunikationsanfrage reagiert, wird ein Reset der USB Function durchgeführt, sie kann nun eine höhere Stromstärke aus dem USB anfragen und ihr wird eine Adresse zugewiesen \cite[S.94f]{Kelm}. Daraufhin fragt der Host eine Beschreibung des USB-Geräts ab und wählt anhand dieser Beschreibung einen passenden Treiber aus \cite[S.95]{Kelm}. USB unterstützt mehrere Transfermodi, um verschieden Anwendungsfälle abzudecken. 
	\begin{itemize}
	\item Der Standardmodus ist ein {\it Control-Transfer}, welcher es erlaubt, geringe Datenmengen als Blöcke zu Senden und zu Empfangen. Dieser Modus ist dazu gedacht, Endgeräte zu konfigurieren und zu steuern. Jedes USB Gerät muss diesen Modus unterstützen, da zum Verbindungsaufbau Befehle in darüber gesendet werden \cite[S.79]{axelson}.
	\item Um große Datenmengen mit einem möglichst geringen Overhead üertragen zu können, wird der {\it Bulk-Transfer} genutzt. Im Gegenzug zu einem Datendurchsatz wird eine solche Übertragung im Bus niedrig priorisiert, um zeitkritischeren Geräten den Vorrang zu geben \cite[S.85]{axelson}. Dieser Modus wird besonders von Massenspeichergeräten um Dateien vom Speichermedium über den Bus zu übertragen oder auf das Speichermedium aus dem Bus zu schreiben.
	\item Ein {\it Interrupt-Transfer} kann genutzt werden um geringe Datenmengen zeitkritisch übertragen zu können. Der Name suggeriert, dass Functions Hardware-Interrupts auslösen können, jedoch stellt eine solche Übertragung lediglich eine Priorisierung der anstehenden Daten dar \cite[S.88]{axelson}. Interrupt-Transfer kommt vor Allem bei Eingabegeräten des Nutzers zum Einsatz, damit keine spürbare Latenzzeit entstehen kann.
	\item  Wenn tatsächlich Daten in Echtzeit übertragen werden sollen, kommt ein {\it Isochrone-Transfer}in Frage. Diese Art von Übertragung erlaubt es, mehr Daten als ein Interrupt-Transfer über den Bus zu senden, jedoch können Aufgrund der zeitkritschen Natur einer solchen Übertragung keine fehlerhaften Daten erneut übertragen werden \cite[S.85]{axelson}.
	\end{itemize}
	Abhängig vom Anwendungsfall muss aus diesen Modi ein passender Transfermodus gewählt werden. Im Fall von Android Open Accessory werden die Geräte über einen Bulk-Transfer angesprochen, um eine höchstmögliche Datenrate zu bieten.
	\subsubsection{Android Open Accessory}
	
	Um ein Android Gerät über USB ansteuern zu können, ist es nötig, das Android Open Accessory (AOA) Protokoll in der Anwendung zu implementieren. Hierbei wird das Androidgerät auf Hostseite im Bulk-Transfer geöffnet und es werden zwei Befehle über USB ausgetauscht. Zunächst muss der Host die unterstützte Accessory Protokoll Version vom Android Gerät abfragen und seine Kommunikation darauf auslegen. Im nächsten Schritt gibt der Host Details über sich selbst dem Android Gerät bekannt. Dies geschieht durch eine Menge von Strings, die dem Nutzer gezeigt werden und einem URI-Link, über welchen passende Anwendungen auf dem Smartphone ausgewählt werden können. Sobald der Host alle diese Daten gesendet hat, wird der Befehl, dass ein Accessory nun von Android zu nutzen ist, über den Control-Transfer ausgespielt \cite{aoa}.