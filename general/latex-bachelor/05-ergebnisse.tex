\section{Ergebnisse der Evaluation}
		Durch die Betrachtung der Umsetzungsmöglichkeiten der einzelnen p2p Technologien kann nun eine Evaluation auf Grundlage der definierten Ziele vorgenommen werden. Zum Vergleich wird Wi-Fi Direct als bereits implementierte Technologie genutzt, um einen Bezug zur bestehenden Lösung aufbauen zu können.
		\subsection{Zuverlässigkeit}
		Die Robustheit der einzelnen Technologien bei Fehlern und die Reproduzierbarkeit von Verbindungen bilden zusammen das Kriterium der Zuverlässigkeit. Wie bei Wi-Fi Direct bereits deutlich wurde, sind diese beiden Punkte nicht zwingend für jede Technologie ausreichend gegeben.
		
		\subsubsection{Wi-Fi Direct} Eine hohe Fehleranfälligkeit in Kombination mit einer schlechten Fehlererholung durch Abstürze des laufenden Wi-Fi Daemon führen zu einer unzureichenden Zuverlässigkeit von Wi-Fi Direct. Ebenso konnte beobachtet werden, dass die internen Zustände der genutzten Bibliothek weder dokumentiert sind, noch waren diese Zustände sauber voneinander gekapselt, wodurch der Erfolg eines Verbindungsaufbaus von vorhergehenden Verbindungen abhängt. Die internen Zustandswechsel konnten zwar über Events der Bibliothek beobachtet werden, jedoch wurden daraus die Menge der möglichen Zustände und deren Übergänge nicht deutlich, da nicht zwingend jedes Event einem neuen Zustand entspricht. Die Dokumentation des {\it wpa\_supplicant} versäumt es ebenfalls zu beschreiben, in welcher Reihenfolge ein erfolgreicher Verbindungsaufbau vollzogen wird, wodurch nicht sichergestellt werden kann, dass die eigene Anbindung der erwarteten Nutzung entspricht.
		Zwar steht der Sourcecode der {\it wpa\_supplicant} Bibliothek und damit auch die Schnittstelle als Sourcecode zur Verfügung, da jedoch die Schnittstelle über Nachrichten statt über Methoden genutzt wird, ist es schwierig zu erkennen, welche Teile des Sourcecodes relevant sind. Es kommt hierbei erschwerend hinzu, dass nicht jede Bibliothek mit den gleichen Parametern gebaut wird, wodurch nicht zwingend der volle Funktionsumfang zur Verfügung steht. Ebenso muss dafür gesorgt werden, dass sich das Wi-Fi Gerät im zuhörenden Modus befindet und somit auf anfragen reagiert. Sobald ein Befehl auf einer anderen Schnittstelle ausgeführt wurde, wechselt das Wi-Fi Gerät vom zuhörenden Modus weg, wodurch eine weitere Nutzung erst dann möglich ist, wenn das Gerät wieder explizit zum Zuhören auf der Wi-Fi Schnittstelle gezwungen wird.
		
		\subsubsection{Bluetooth} Im Gegensatz dazu konnte mit Bluetooth und der genutzten Bibliothek ein \linebreak Verbindungsaufbau mit reproduzierbaren Ergebnissen erreicht werden. Durch das integrierte Hilfsmittel {\it bluetoothctl} der BlueZ Bibliothek kann die Menge der bestehenden Zustände gut beobachtet werden. Die Benennung der einzelnen Zustände orientiert sich hierbei an der theoretischen Spezifikation von Bluetooth, wodurch auch die Zustandsübergänge bereits klar werden. Eine feinere Betrachtung der Zustände ist nicht nötig, da die Bluetooth Bibliothek jeglichen Zustand der Verbindung selbstständig verwaltet und dies der Anwendung als Serversocket zur Verfügung stellt. Fehler werden somit als Schließen des Sockets oder Fehler des Verbindungsaufbaus bekannt gemacht. Daraus lässt sich nicht der exakte Grund Ableiten lässt, jedoch besitzt Bluetooth aufgrund des saubere definierten Zustandsmodells und durch Socketverbindungen auch die Anbindung von Bluetooth eine solche Fehlerstabilität, dass die Verbindung lediglich neu aufgebaut werden muss \cite{bluetoothSpec}. Für eine Bluetoothverbindung muss jedoch auch  sichergestellt werden, dass das Gerät über Bluetooth aufgefunden werden kann.
		
          \subsubsection{NFC} Wenn ein bereits bestehender Wrapper genutzt wird, besteht das Problem, dass nicht ersichtlich ist, wann Fehler auftreten können. Die Kapselung auf Socketverbindungen für NFC ermöglicht es jedoch auch, eine Behandlung von Fehlern durch das Schließen bestehender Verbindungen durchzuführen und eine Verbindung erneut aufzubauen. Die internen Zustände eines NFC Verbindungsaufbaus lassen sich nicht direkt über die genutzte Bibliothek {\it libnfc} beobachten, jedoch kann über das Hilfsmittel {\it nfc-poll} ein NFC Gerät und die ausgetauschten Befehle ausgelesen werden. Eine Reproduzierbarkeit von Verbindungen ist durch das von NFC genutzte Trägersignal zwar gegeben, jedoch wird in der genutzten Implementierung ein hochfrequentes {\it Keep-Alive} Signal genutzt, damit die Verbindung aufrecht erhalten wird.
     
          \subsubsection{USB} Ähnlich zu NFC schränkt die bestehende Implementierung von USB das Fehlerverhalten der zugrundeliegenden {\it libusb} Bibliothek ein und bündelt dieses ebenfalls über eine Socketverbindung. Da der Verbindungsaufbau von USB Geräten bereits vom Kernel übernommen wird, können Zustandsübergänge an neuen Geräten über {\it udev} beobachtet werden. Eine Fehleranfälligkeit der USB Verbindung ergibt sich aus den genutzten Treibern. Da jedoch das USB-Gerät ohne Treiber mit {\it libusb} angesprochen wird, besteht eine sehr geringe Fehleranfälligkeit einer USB Verbindung, da diese kabelgebunden ist und sich erst eine Fehleranfälligkeit aus den genutzten Treibern oder einer Abweichung von der USB Spezifikation ergibt \cite{usbSpec}. Die Spezifikation sieht eine Fehlererholung so vor, dass der Host der Verbindung laufende Datentransfers steuern kann. Diese Fehler werden erst propagiert, wenn sie nicht erfolgreich abgefangen werden konnten. Diese Fehler tauchen dann lediglich im Log des Kernels auf und resultieren in einem Zurücksetzen der USB Verbindung über das Hotplugging von USB.
		
		\subsection{Wartbarkeit}
		Fehler in der Nutzung einer Technologie lassen sich nur dann leicht beheben, wenn die Dokumentation so vollständig ist, dass sie den betroffenen Nutzungsfall abdeckt und somit eine Abweichung der Anbindung von der Dokumentation aufgedeckt werden kann. Sollte die Dokumentation jedoch nicht ausreichend auf diesen Fall eingehen, muss der Quellcode der angebotenen Schnittstelle zur Verfügung stehen und leicht zu verstehen sein, sodass die Abweichung leicht gefunden werden kann. Sollten Tests für die genutzten Bibliotheken im Sourcecode vorhanden sein, verbessert dies die externe Wartbarkeit ebenfalls, da so zum Einen bereits eine Abstraktion der Hardware besteht und diese für eigene Tests genutzt werden kann und zum Anderen die Nutzung der Bibliothek anhand der getesteten Nutzungsfälle exemplarisch gezeigt wird.
		
		\subsubsection{Wi-Fi Direct} Die Dokumentation von Wi-Fi Direct ist bei der Wi-Fi Association nicht öffentlich zugänglich, jedoch enthält die Beschreibung der {\it wpa\_supplicant} Implementierung eine Aufstellung einiger Ereignisse, die bei der Nutzung auftreten können. Fehler beim Verbindungsaufbau oder während der Verbindungsnutzung werden zwar als solche Ereignisse der Anbindung mitgeteilt, jedoch ließen sich auch eine mangelnde Fehlerrobustheit durch Abstürze bei einigen dieser Ereignisse feststellen. Tests sind im {\it wpa\_supplicant} für die einzelnen Schritte eines p2p Verbindungsaufbaus als Python-Skripte vorhanden und basieren auf einer simulierten Hardware. Diese simulierte Hardware lässt sich somit auch für eigene Tests nutzen, um die eigene Implementierung mit möglichst geringen Abänderungen testen zu können.
		
		\subsubsection{Bluetooth} Eine Anbindung an Bluetooth geschieht über Sockets, welche bei der Erstellung durch das Austauschen einiger Parameter bereits eine testbare Umgebung bereitstellen können. Weiterhin wird die Spezifikation von Bluetooth durch die Bluetooth SIG öffentlich einsehbar bereitgestellt und beschreibt ausführlich interne Zustände einer Bluetooth Implementierung sowie die Testbarkeit eines Bluetoothgerätes \linebreak \cite{bluetoothSpec}. Die BlueZ Bibliothek steht ebenfalls als Referenz zur Verfügung und enthält in den Tests ebenfalls eine Beispielanbindung für die \linebreak Nutzungsfälle der Bibliothek jedoch keine Virtualisierung der Hardware. Dies bedeutet, dass für einen vollständigen Integrationstest mindestens zwei Bluetoothschnittstellen am testenden Gerät vorhanden sein müssen, da ein Loopback ebenfalls nicht möglich ist.
		
		\subsubsection{NFC} Die existierende Lösung nutzt ebenfalls Sockets um eine Kommunikation aufbauen zu können, somit kann auch hier die eigene Implementierung getestet werden, indem dieser Serversocket angesprochen wird. Um auch die Kapselung der NFC Bibliothek testen zu können, ist es nötig, die zugrundeliegende Bibliothek {\it libnfc} zu betrachten. In ihr finden sich sowohl Beispiele für alle unterstützten Nutzungsfälle des genutzten NFC Chips als auch Tests der Bibliothek. Eine Dokumentation der Bibliothek als solche existiert nur minimal, jedoch können die Beispiele genutzt werden eine Implementierung vorzunehmen. Eine Konfiguration von Geräten, die mit der Bibliothek genutzt werden sollen, ist nötig, da die NFC Bibliothek UART zur Kommunikation nutzt und Geräte somit nicht automatisch als NFC-Modul erkannt werden. Ein solcher Konfigurationsaufwand verschlechtert auch die Wartbarkeit der Anbindung, da diese Anbindung nicht ohne die Konfiguration funktionieren kann und sich nicht testen lässt ob eine Konfiguration für alle Anwendungsfälle korrekt ist oder nur für einen getesteten Anwendungsfall richtiges Verhalten zeigt, da eine Dokumentation über die Konfigurationsmöglichkeiten nicht gegeben ist. 
		
          \subsubsection{USB} Eine Spezifikation über USB kann öffentlich eingesehen werden, jedoch umschließt diese nicht nur die Definition eines Übertragungsprotokolls sondern auch die \linebreak vollständige Definition der Hardwareschnittstelle, wodurch die für das Protkoll relevanten Teile schwer auffindbar sind und die Spezifikation dadurch einen geringeren Nutzen im Vergleich zu den anderen Technologien aufweist \cite{usbSpec}. Socketverbindungen werden auch hierbei von der genutzten Implementierung für die Dauer der USB Verbindung aufgebaut und im nicht erholbaren Fehlerfall geschlossen. Intern werden Daten über explizit blockierende Methoden gesendet und empfangen, welche auch Fehler der Verbindung als Resultat ausliefern. Jeder dieser Fehler ist in der Dokumentation der {\it libusb} dokumentiert und gibt Aufschluss darüber, wodurch dieser Fehler aufgetreten ist. Die Bibliothek kann ebenfalls im Quellcode eingesehen werden und enthält Beispiele sowie Tests.
     Einige Beispiel werden ebenfalls gleichzeitig als Tests genutzt, jedoch ist zu beobachten, dass nur sehr grundlegende Tests der Bibliothek durchgeführt werden und keine Tests existieren, die eine vollständige Datenübertragung über ein virtuelles USB Gerät überprüfen. Da das AOA Protokoll implementiert wird, ist es auch nicht möglich, einen Test ohne ein Android Gerät zu vollziehen, da nicht geprüft werden kann, dass die im Protokoll gesendeten Daten auch im vorgesehenen Format gesendet wurden. Testbarkeit und damit auch Wartbarkeit ist somit nur bedingt für eine USB Schnittstelle gegeben.
		
		\subsection{Funktionalität}
      Da sich der genutzte Funktionsumfang nicht zwischen den Technologien unterscheidet, ist es schwierig für den Punkt der Funktionalität ein zu überprüfendes Kriterium zu definieren. Daher wird hier auf die Dokumentation und Erreichbarkeit der internen Zustände der Technologie eingegangen. Diese Zustände können vereinfacht als die Zustände einer p2p Verbindung, wie in \reffig{p2p:state} beschrieben, betrachtet werden. Ebenso ist im Rahmen der Funktionalität zu betrachten, wie leicht sich der nötige Funktionsumfang über eine der Technologien bereitstellen lässt.
      
		\subsubsection{Wi-Fi Direct} Die internen Zustände von Wi-Fi Direct lassen sich nur bedingt auf Wi-Fi Direct abbilden, da der Verbindungsaufbau zu einem Gerät nicht vollständig automatisch stattfinden kann und somit die Zustände {\it ACCEPTING} und {\it CONNECTING} sich nicht als jeweils ein atomarer Zustand abbilden lassen. Ebenso ist es der Zustand {\it CONNECTED} unvollständig, da nicht beiden Verbindungsteilnehmern die IP-Adresse des Gegenüber mitgeteilt wird und diese über einen weiteren Kanal übertragen werden muss.
		Wi-Fi Direct stellt eine p2p Verbindung bereit, indem ein Netzwerkadapter für eine ad-hoc Gruppe angelegt wird. Dieser Netzwerkadapter hat Zugriff auf die Sockets des verbundenen Gerätes und spricht dieser über IP Pakete an. Da die Sockets direkt angesprochen werden können, entfällt für diese Technologie ein HTTP Wrapper, wodurch die Anbindung eher einer Konfiguration als einer Implementierung entspricht. Um diese Konfiguration vornehmen zu können muss jedoch die externe Schnittstelle des {\it wpa\_supplicant} angebunden werden. Da diese auf Nachrichten basiert muss nur eine geringe Menge an Methoden implementiert werden, jedoch muss die Menge der möglichen Nachrichten auch unterstützt werden. Nicht jede Nachricht, die genutzt wird ist hierbei dokumentiert, wodurch der Aufwand, die nötige Funktionalität anzubieten, sich erhöht. Um eine Verbindung erfolgreich aufbauen zu können, müssen nötige Events abgefragt werden und aktiv im Verbindungsaufbau mitgewirkt werden. Dadurch wird der Verbindungsaufbau unzuverlässig und somit auch aufwändiger umzusetzen.
		
		\subsubsection{Bluetooth} Gegenüber Wi-Fi Direct ist die Implementierung von Bluetooth so stark gekapselt, dass ein Verbindungsaufbau in den Zuständen {\it ACCEPTING} und {\it CONNECTING} dargestellt werden kann. Nachdem beide Geräte in den Zustand {\it CONNECTED} gewechselt haben, können beide Geräte über Sockets miteinander kommunizieren. Bluetooth ist so vollständig durch das simple Zustandsmodel von p2p Verbindungen abgebildet und kann dessen Funktionsumfang vollständig bereitstellen. Da Bluetooth Sockets verwendet, um eine p2p Verbindung zu realisieren, können lediglich Standardmethoden eines jeden Linuxsystems genutzt werden, um erfolgreich eine Verbindung herzustellen. Sockets sind darauf ausgelegt, eine simple Implementierung von Interprozesskommunikation zur Verfügung zu stellen, was sich bei dieser Implementierung zunutze gemacht wurde.
		
	  \subsubsection{NFC} NFC nutzt ein Trägersignal, um Daten zu übertragen. Dieses Trägersignal wird selbstständig auf und abgebaut, und stellt den Zustand {\it CONNECTED} dar. Eine Kommunikation auf Seiten von Android findet über einen zuvor definierten Service statt, welcher angesprochen wird, wenn auf einen Befehl reagiert werden muss. Es ist dabei aber nicht ersichtlich, wie der Zustandsübergang zwischen {\it IDLE} und {\it CONNECTED} gehandhabt wird. Somit sind die Zustände {\it ACCEPTING} und {\it CONNECTING} durch NFC nicht nach außen hin abgebildet. Dadurch wird es komplizierter, asynchrone Daten über diese Schnittstelle zu senden, da die Daten in einer Schlange vorgehalten werden müssen und die Verbindung über leere Datenpakete aufrecht erhalten werden muss. Die verbleibende Implementierung besteht daraus, Datenpakete von der NFC Bibliothek abzufragen und auf Diese zu reagieren indem Sockets verwaltet werden. Da jedoch für diese Schritte eine existierende Lösung genutzt werden konnte, besteht kein Implementierungsaufwand, um die nötige Funktionalität anzubieten.
	  
     \subsubsection{USB} Da USB als einzige vorgestellte Technologie ein kabelgebundenes Medium ist, \linebreak entspricht im Zustandsdiagramm einer p2p Verbindung der Zustand {\it IDLE} gleichzeitig dem Zustand {\it ACCEPTING} auf einem Hostgerät. Auf dem Clientgerät wird durch das Verbinden mit dem Host über das Kabel eine Spannung übertragen und das Gerät wechselt intern zum Zustand {\it CONNECTING} um sich beim Host zu registrieren. Sobald das Hotplugging-Event auf dem Hostgerät erhalten wurde, wird es geöffnet und über AOA eine Verbindung hergestellt. Danach befindet der Host sich im Zustand {\it CONNECTED} und kann vom Client als USB Accessory angesprochen werden. Das USB Accessory besitzt dabei Inputstream und Outputstream somit befindet sich auch der Client im Zustand {\it CONNECTED}.
     Um die p2p Funktionalität bereitstellen zu können, ist es nötig, die Bibliothek {\it libusb} so anzubinden, dass Hotplugging-Events abgefangen werden und eine blockierende Kommunikation über die Bibliothek stattfindet. Um AOA noch zu implementieren, muss der Host zwei USB Befehle implementieren, um eine gemeinsame Protokollversion zu finden und sich dem Smartphone gegenüber zu identifizieren. Es wurde versucht eine bestehenden Lösung zu nutzen, welche eine eigene Implementierung überflüssig gemacht hätte, jedoch konnte kein erfolgreiches Ergebnis mit dieser Lösung erzielt werden, wodurch eine eigene Implementierung doch nötig ist.
		
		\subsection{Effizienz}
	   Der Begriff der Effizienz setzt sich aus Datenraten der Verbindung sowie möglichen Differenzen in der Antwortzeit aufgrund der genutzten Technologie zusammen. Da für drahtlose Netzwerkverbindungen mittlere Antwortzeiten jedoch stark von Interferenzen abhängen und sich keine reproduzierbaren Ergebnisse erzielen ließen, kann über diesen Punkte keine Aussage getroffen werden. Da realse Datenraten stark von Interferenzen und anderen Störfaktoren abhängig sind, werden lediglich die theoretischen Datenraten gegenüber gestellt. Gemessen werden die Datenraten in Kilobit pro Sekunde (kbps).

		\subsubsection{Wi-Fi Direct} Die mögliche Übertragunsrate von Wi-Fi Direct hängt von den genutzten Geräten ab und welcher Teil des Standards {\it IEEE 802.11} von ihnen unterstützt wird. Theoretisch sind dabei Datenraten bis zu 250.000kbps möglich \cite{wifiRate}. Da nicht aktiv in Verbindungen eingegriffen wird entsteht hierbei auch kein Overhead der Anwendungsseite für die Übertragung.
		
		\subsubsection{Bluetooth} Der genutzte Raspberry Pi verwendet Bluetooth in der Version 4.2. Somit kann eine Bluetooth Verbindung basierend auf {\it IEEE 802.11a} aufgebaut werden, wodurch eine theoretische Datenrate von 24.000kbps möglich ist.
		
		\subsubsection{NFC} Theoretisch unterstützt NFC die Datenraten 106kbps, 212 kpbs und 424kbps \linebreak \cite{nfcRates}, jedoch können diese Datenraten einer Verbindung über NFC mit einem Android Telefon nicht erreicht werden, da Android keine erweiterten Tag-Pakete unterstützt \cite{nfcBug} und so nur 255 Byte Nutzdaten pro Paket möglich sind. Hierdurch erhöht sich Overhead für Befehle im Vergleich zu Nutzdaten von 0,01\% auf 2,68\% deutlich und die Nutzdaten einer Socket Verbindung erhalten noch weiteren Overhead, da Befehle zur Steuerung der externen Sockets ebenfalls zur Verfügung stehen müssen.
		
		\subsubsection{USB} Im verwendeten Raspberry Pi wird USB 2 unterstützt, wodurch USB eine Datenrate von 12.000kbits im {\it Full Speed} Modus und 480.000kbits im {\it High Speed} Modus. Die Verwendung von AOA schränkt diese Datenraten nicht ein, da über dieses Protokoll lediglich ausgetauscht wird, welches Gerät an das Android Smartphone angeschlossen wurde, damit eine passende Anwendung ausgewählt werden kann.
		
		\subsection{Bedienbarkeit}
      Im Rahmen der Bedienbarkeit soll der Aufwand betrachtet werden, den der Nutzer aufbringen muss, um eine Verbindung über die Technologien erfolgreich aufbauen zu können. Dieser Aufwand lässt sich daran messen, wie viele Aktionen der Nutzer ausführen muss, bevor eine p2p Verbindung besteht.
      
		\subsubsection{Wi-Fi Direct} Für eine Verbindung über Wi-Fi Direct muss die Wi-Fi Schnittstelle des Telefons eingeschaltet sein, was sich mit der entsprechenden Berechtigung ohne Nutzerinteraktion erreichen. Im nächsten Schritt wählt der Nutzer, wie bei allen Technologien, das zu verbindende Gerät aus. Um eine Verbindung zu dem gewählten Gerät aufzubauen, muss der Nutzer in einem Dialog des Systems bestätigen, dass der Verbindungsaufbau erwünscht ist. Sobald der Nutzer dies bestätigt hat, wird der Verbindungsaufbau abgeschlossen und beide Geräte sind in einem Netzwerk miteinander verbunden. Es ist also eine einzelne Aktion des Nutzers für eine Wi-Fi Direct Verbindung von Nöten.
		
		\subsubsection{Bluetooth} Bevor eine Bluetooth Verbindung aufgebaut werden kann, muss das Android-Gerät Bluetooth aktiviert haben. Wenn der Nutzer der App Administrator Rechte über Bluetooth erlaubt hat, kann dies bereits automatisch geschehen. Bluetooth muss aktiv sein, damit zum einen Service Discovery über Bluetooth LE stattfinden kann und eine p2p Verbindung aufgebaut werden kann. Der eigentliche Aufbau der p2p Verbindung geschieht automatisch zwischen den beiden Bluetooth-Stacks ohne einen Eingriff des Nutzers, da  ein temporäres Pairing für die Dauer der Verbindung vorgenommen wird. Der Nutzer muss somit keine Aktionen durchführen um eine p2p Verbindung zu einem Gerät über Bluetooth aufzubauen.
		
		\subsubsection{NFC} Um NFC nutzen zu können, muss auch hier der Nutzer wieder sicherstellen, dass NFC in den Einstellungen des Smartphones eingeschaltet ist, jedoch kann dies nicht ohne Eingriff des Nutzers geändert werden. Ebenso muss der Nutzer für die Dauer der Datenübertragung beide Geräte auf einer Distanz von unter 10 Zentimetern halten, was beim aktuellen Nutzerfluss der Verbindungskonfiguration mindestens zwei Mal geschehen muss, da davon auszugehen ist, dass die Verbindung geschlossen wird, sobald der Nutzer mit der App interagieren muss.
		
           \subsubsection{USB} Die Verbindung über USB erfordert zunächst, dass das Android-Gerät über ein USB Kabel durch den Nutzer mit dem Raspberry Pi verbunden wird. Zusätzlich muss der Nutzer dann auf neueren Android-Betriebssystemversionen die USB-Verbindung zur Datenübertragung erlauben. Da in der eigenen Umsetzung jedoch keine erfolgreiche Datenübertragung vollzogen werden konnte, ist auch eine Bedienbarkeit der Schnittstelle nicht gegeben.
		
		\subsection{Zusammenfassung}

		Generell lässt sich sagen, dass jede der vorgestellten Technologien im Hinblick auf die überprüften Kriterien einen anderen Schwerpunkt besitzt. \reffig{fig:rating} zeigt eine Aufstellung der einzelnen Technologien im Hinblick auf die geprüften Evaluationskriterien. Zwar lässt sich keine qualitative oder quantitative Bewertung für die einzelnen Werte treffen, wodurch die Verhältnisse zwischen den einzelnen Technologien nicht repräsentativ sind, jedoch lassen sich anhand dieses Graphen leicht die Stärken und Schwächen der p2p Übertragungsmedien gegenüberstellen.
		
		Bluetooth weißt einen hohen Nutzen im Hinblick auf Funktionalität, Wartbarkeit und Bedienbarkeit auf. Insgesamt zeigt sich so, dass Bluetooth als p2p Technologie am Besten geeignet ist, da sie auch gute Zuverlässigkeit bietet.
		
		Wenn Bluetooth nicht genutzt werden kann, sollte als Nächstes NFC in Betracht gezogen werden. Es besitzt zwar die schlechteste Effizienz aller Technologien, jedoch erfüllt es die Kriterien der Funktionalität und Wartbarkeit immer noch gut. Es besitzt eine höhere Zuverlässigkeit gegenüber den anderen Technologien jedoch wird auch die Benutzbarkeit durch die starke Nutzereinbindung in Mitleidenschaft gezogen.
		
		Effizienz ist für den Anwendungsfall der Verbindungskonfiguration, welche eine REST-Schnittstelle darstellt, eher unerheblich, da alle Technologien, sobald eine Verbindung aufgebaut wurde, geringe Datenmengen schnell genug übertragen können. USB stellt für dieses Kriterium jedoch die beste Wahl dar, sollte dieser Punkt für ein anderes Evaluationsziel relevant sein.
		
		Wi-Fi Direct kann in keiner der geprüften Kategorien hervorstechen und zeigt lediglich eine gute Effizienz und Bedienbarkeit. Für alle anderen Evaluationspunkte ist davon abzuraten, Wi-Fi Direct als p2p Technologie einzusetzen.
		
    \begin{figure}[ht]
    \centering
    \begin{tikzpicture}
        \tkzKiviatDiagram[scale=1.0,label distance=.25cm, gap = 1, lattice = 4]{Zuverlässigkeit,Wartbarkeit,Funktionalität,Effizienz,Bedienbarkeit}
        %Wi-Fi Direct:
        \tkzKiviatLine[thick,color=red, fill=red!20,opacity=.5](2,1,1,3,3)
        %Bluetooth:
        \tkzKiviatLine[thick,color=blue, fill=blue!20,opacity=.5](3,4,4,2,4)
        %NFC:
        \tkzKiviatLine[thick,color=yellow, fill=yellow!20,opacity=.5](4,3,3,1,2)
        %USB:
        \tkzKiviatLine[thick,color=green, fill=green!20,opacity=.5](1,2,2,4,1)
    \end{tikzpicture}
    \caption[Netzdiagramm der p2p Technologien in den Evalutaionskriterien]{Dieses Netzdiagramm der p2p Technologien in den Evalutaionskriterien zeigt, wie stark die einzelnen Kriterien von den Technologien abgedeckt werden. Je größer die gesamte Fläche, die eine Technologie dabei bildet, ist, desto besser ist sie als p2p Technologie zur Vebrindungskonfiguration geeignet. {\bf Blau} entspricht hierbei Bluetooth, {\bf Rot} stellt Wi-Fi Direct dar, {\bf Grün} wird von USB genutzt und der {\bf gelbe} Graph repräsentiert NFC. } \label{fig:rating}
    \end{figure}