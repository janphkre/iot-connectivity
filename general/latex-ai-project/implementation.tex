\section{Umsetzung}
	Um eine stabile Lösung schnell und simpel anbieten zu können, wird zur Implementierung der REST-Schnittstelle auf bestehende Server sowie Client Bibliotheken zurückgegriffen. Diese bieten somit die Möglichkeit die Implementierung dieser Schnittstelle deskriptiv vorzunehmen. In Android wird somit die Implementierung zur Laufzeit aus einer Schnittstellenbeschreibung generiert und auf der Serverseite müssen so nur die Implementierungen der Methoden beschrieben werden. Da die Wahl des Übertragungsmediums auf Wi-Fi Direct gefallen ist, können ebenso Teile des Betriebssystems und Standardbibliotheken zum Broadcast und Aufbau der p2p Verbindung genutzt werden.
	Da unter Linux das Paket wpa\_supplicant \cite{wpaSupplicant} auf allen gängigen Distributionen, so auch unter raspbian auf dem Raspberry Pi, dazu genutzt wird, Wi-Fi Schnittstellen und Netzwerke zu verwalten. Es läuft als daemon im Betriebssystem mit und kann über ein Kommandozeileninterface bedient werden oder mit einer C-Schnittstelle in das eigene Programm eingebunden werden.
	\subsection{Pharo}
		Auf der Serverseite in Pharo besteht die Implementierung aus der Anbindung der wpa\_supplicant Schnittstelle, einem C-Modul für diese Anbindung, den Methoden des REST-Servers und einem Modul, welches die p2p Verbindung und Service Discovery handhabt.
		Die Anbindung des wpa\_supplicant beginnt damit, dass aus der hostap \cite{hostAp} Bibliothek ein C-Modul kompiliert werden muss, welches es erlaubt, das interne Control Interface (common/wpa\_ctrl.c) zu nutzen. Darauf aufbauend muss in pharo eine Klasse geschaffen werden, die in der Lage ist, Handle (LWpaHandle) des Control Interfaces zu verwalten und deren Zustand persistent zu speichern. Persistenz ist nötig, da die pharo-VM zwischen Nachrichten gestoppt und zu einem anderen Zeitpunkt erst wieder fortgesetzt werden kann. Wenn verwendete Netzwerkschnittstellen vom Gerät entfernt werden, muss dies dann auch aus der Bibliothek als Fehler signalisiert werden. Weiterhin müssen Events über Polling an Listener signalisiert werden und außerhalb des wpa\_supplicant kann die Liste der verfügbaren Schnittstellen abgefragt werden.
		
		Basierend auf dieser Anbindung wird LWpaInterface als einheitliche Fassade genutzt, die alle genutzten Nachrichten, die an den wpa\_supplicant gesendet werden können, als Methoden implementiert.
		In diesem Interface sind alle Methoden der p2p Service Discovery über p2p Verbindungsaufbau und Netzwerkscans bis hin zur Netzwerkkonfiguration enthalten. Alle Methoden stehen auch auf allen Netzwerkgeräten zur Verfügung, es ist aber zu erwarten, dass bei nicht unterstützten Methoden ein Fehler auftritt.
		Die p2p Komponente, welche Service Discovery und p2p Verbindungsaufbau ermöglicht, ist ein einzelnes Objekt, welches über start und stop Methoden verfügt, um die Softwarelösung als gebündelte Einheit zu betreiben. Dieses Objekt startet auch gleichzeitig den REST-Server auf einem definierten Port, da dieser Port in der p2p Service Discovery angegeben werden muss, damit Clients den Server auch nutzen können. Weiterhin sind für Wi-Fi Direct Event Handler nötig, die auf Events zum Verbindungsaufbau reagieren und Verbindungen akzeptieren.
		
		Zur Implementierung des REST-Servers müssen die Methoden, die der REST-Server anbieten soll, als Kinder einer abstrakten Klasse (ICCall) definiert werden, sodass die Liste der Kinder dem REST-Server zugeliefert werden kann.
		Jede Klasse beschreibt dabei einen Pfad des Servers auf dem ein oder mehrere Http-Verben implementiert werden. Da manche Methoden jedoch auf anderen Methoden aufbauen, wird zwischen der wpa\_supplicant Bibliothek und der Methodenimplementierung eine Logikschicht (IC...Wrapper) eingebaut, welche es erlaubt, die noch nicht in JSON umgewandelten Resultate (ICData) in mehreren REST-Methoden abzufragen.
		
	\subsection{Android}

		Die Android App besteht aus zwei Modulen, einem Frontend, welches die anzuzeigenden Daten über RxJava asynchron abfragt und einem Modul, welches die p2p Broadcasts abfragt sowie die p2p Verbindung aufbaut.
		Die App besteht aus einer Reihe einfacher Bildschirme, die größtenteils bloß Listen der abgefragten Daten anzeigen. Wie in \figurename \ref{user_flow} zu sehen, ist der Nutzerfluss durch die Bildschirme, dass der Nutzer zunächst eine Liste der in der Nähe aktiven p2p Geräte angezeigt bekommt und eines dieser Geräte auswählt. Durch die Auswahl wird eine p2p Verbindung mit dem Gerät aufgebaut, sodass der REST-Server genutzt werden kann. Während der Nutzer einen Ladebildschirm sieht, wird so die Liste der verfügbaren Netzwerkschnittstellen, die nicht exklusiv für p2p vorhanden sind, abgefragt und dem Nutzer angezeigt. Sollte diese Liste nur einen Eintrag enthalten, wird die Auswahl der Netzwerkschnittstelle automatisch vorgenommen und es wird zur nächsten Ansicht vorangeschritten. Der Nutzer sieht hierbei nach wie vor den Ladebildschirm. Sind jedoch mehrere Elemente in der Liste, wird dem Nutzer die Liste angezeigt. Wählt der Nutzer eine der Netzwerkschnittstellen aus, wird ihm eine Liste der aktuell erreichbaren Netzwerke gezeigt, sodass er das Gerät mit Netzwerken verbinden kann, wie es auch in den Einstellungen des Smartphones möglich ist.
		
		Um die Module miteinander zu verbinden, wird Koin \cite{androidKoin} als Dependency Injection in Verbindung mit öffentlich definierten Schnittstellen genutzt. Koin verzichtet im Gegensatz zu Dagger auf generierten Code. Dadurch ist es zwar im Setup langsamer, jedoch macht es für die eigentliche Injection der Abhängigkeiten keinen erheblichen Unterschied mehr, sodass diese Bibliothek auf Grund ihrer leichten Einbindung genutzt wurde \cite{androidKoinSpeed}. Als REST-Client wird hierbei Retrofit in Kombination mit Gson genutzt. Retrofit erlaubt es, die REST-Schnittstelle deklarativ zu definieren, sodass jeglicher Code generiert wird. Dies hat den Vorteil, das kein Boilerplate-Code geschrieben werden muss. In Verbindung mit Gson lässt sich so eine saubere REST-Schnittstelle mit einem klar strukturierten Datenmodell umsetzen, da gson es erlaubt, Datenobjekte aus Klassen zu erzeugen, in denen die Felder mit dem gelieferten JSON Objekt korrespondiert.

	\subsection{Stolpersteine}
		Bei der Umsetzung des Projektes sind einige unvorhergesehene Probleme und Einschränkungen aufgetaucht. Teilweise erforderten diese ein großes Umdenken oder eine lange Suche nach einer alternativen Lösung.
		
		Die Kommandozeilenschnittstelle	des wpa\_supplicant ist dem C-Interface unterlegen, da Events immer im Standardkanal ausgegeben werden. Dies führt dazu, dass bei der Nutzung von Befehlen nicht zwischen eingehenden Events und dem Ergebnis des Befehls unterschieden werden kann. Die C-Schnittstelle erlaubt es hingegen, Events unabhängig von Befehlen abzufragen und auf Diese zu warten. Foreign Function Calls sind in pharo zwar aktuell möglich, jedoch sind diese noch nicht vollständig eingebunden. So wird aktuell noch die gesamte Ausführung in der VM für die Dauer des externen Aufrufs gestoppt, da nicht überblickt werden kann, inwie weit der externe Aufruf Speicherveränderungen durchführt und somit Inkonsistenzen entstehen könnten. Außerdem ist es zum aktuellen Zeitpunkt nicht möglich, mit dem Unified Foreign Function Interface (UFFI) in pharo Callbacks zu Implementieren. Dies bedeutet konkret, dass Events lediglich über ein Polling erhalten werden müssen.
		Weiterhin ist UFFI noch nicht so gut dokumentiert, dass es ohne viele Vermutungen ausprobiert werden muss. Es wurde sich hierbei zwar an bereits bestehendem Code der git Anbindung orientiert, jedoch ist es teilweise undurchsichtig, welche Typen von der VM automatisch übersetzt werden, wie zum Beispiel char* zwar zu String umgewandelt wird, dies jedoch nicht wie ein Stringbuffer funktioniert.
		
		Beim Testen von UFFI besteht das Problem, dass die Aufrufe, die aus pharo getätigt werden, in einem core dump resultieren, falls ein Fehler auftritt und so nicht gespeicherte Änderungen in der VM verloren gehen. Da hierbei viel mit sehr generischem Code gearbeitet wird, der das String Array aus pharo, welches den C-Funktionsaufruf repräsentiert, in einen tatsächlichen Funktionsaufruf umwandelt. Dadurch ist der stacktrace des Codes, der nativ ausgeführt wird, wenig durchsichtig und man bleibt ohne Fehlermeldung dessen, was tatsächlich schief gelaufen ist. Dies ist besonders problematisch im Hinblick darauf, dass die Typauflösung von UFFI nicht ganz deutlich wurde und man somit auf Trial and Error zurückgreifen musste.
		
		Theoretisch blockieren sich die Verwendung von Wi-Fi Direct und gewöhnlichem Wi-Fi mit einem Access Point auf der selben Netzwerkschnittstelle, da diese eine Sende- und Empfangseinheit exklusiv benötigen. Diese Limitierung wird bei Nutzung des wpa\_supplicant jedoch nicht deutlich, da gewöhnliche Schnittstelle und p2p Schnittstelle immer als separate Einheiten auf der gleichen Netzwerkkarte aufgelistet werden. Da manche Netzwerkkarten inzwischen mehr als ein Radio enthalten, um höhere Übertragungsraten zu ermöglichen, kann dies jedoch auf manchen Geräten dennoch funktionieren. Im Falle des Raspberry Pi 3 B ist dies jedoch aktuell nicht möglich und eine zweite Netzwerkkarte wird benötigt, um Wi-Fi Direct und Wi-Fi parallel zu nutzen. Diese Limitierung gilt jedoch nicht für die Service Discovery, die über Wi-Fi Direct stattfindet.
		
		Im Allgemeinen ist die Dokumentation und Spezifikation von Wi-Fi Direct und dessen Implementierung unzureichend. Die Spezifikation konnte von der WiFi Association nicht angefragt werden, somit fehlt sie für dieses Projekt. Da so einzig die Dokumentation des wpa\_supplicant für die Umsetzung genutzt werden konnte, fielen auch hier Lücken auf. So sind nicht alle relevanten Events dokumentiert und es ist noch fraglich, ob die genutzten Events tatsächlich das widerspiegeln, was ihr Name suggeriert. Ebenso fehlt ein State-Graph der p2p Umsetzung, wodurch unklar ist, in welchem Zustand des Verbindungsaufbaus die Netzwerkpartner sich wie zu verhalten haben. Außerdem fehlen Angaben zu den Datagrammen der Service Discovery in der Dokumentation, da Diese direkt binär codiert angegeben werden müssen. Es wurde hierbei auf die Open Source Android Implementierung zurückgegriffen.\cite{androidRepo}
		
		Unter Android steht Wi-Fi Direct vom Betriebssystem als Sammlung von Java Klassen zur Verfügung. Problematisch ist hierbei auch wieder, dass Android oder der intern verwendete wpa\_supplicant einen Cache besitzt, wodurch Daten, die bereits einmal ausgeliefert wurden trotz einer neuen Anfrage nicht noch einmal ausgeliefert werden. Ebenso scheint es eine Blacklist für Geräte zu geben, zu denen ein p2p Verbindungsaufbau mehrfach fehlgeschlagen ist, wodurch auch kein Service Discovery Austausch mehr mit diesem Gerät möglich ist. Dieses Problem ließ sich lediglich durch einen Neustart des Smartphones beheben.
		
		Weiterhin besitzt Wi-Fi Direct die Einschränkung, dass standardmäßig lediglich die Clients die IP Adresse	des Gruppenhosts mitgeteilt bekommen. Dies bedeutet, dass der Anwendungsserver entweder immer die p2p Gruppe hosten muss oder der Anwendungsclient auf einem fix definierten Port oder per Service Discovery die IP Adresse des Anwendungsservers erwarten muss. Dies deutet ein tieferliegendes Problem an, da dem Gruppenhost lediglich mitgeteilt wird, dass Clients der Gruppe beigetreten sind, nicht aber welche IP Adresse ihnen zugewiesen wurde. Dies stellt ein Problem dar, da manche Netzwerkkarten das Hosten einer p2p Gruppe nicht unterstützen und lediglich als p2p Client agieren können. Dieser Fall trifft auch auf den Raspberry Pi 3 B+ zu. Dadurch wird die simple p2p Verbindung erheblich komplexer, da erst ein Verbindungsdatenaustausch auf Anwendungsebene stattfinden muss.
		
		Aus all diesen Faktoren resultiert, dass die Verbindung nicht reproduzierbar stabil zwischen dem Raspberry Pi und einem Android Smartphone aufgebaut werden kann, wodurch eine Nutzbarkeit für Endnutzer hinfällig wird.